## Связи моделей

Данные целесобразно хранить в разных моделях в том случае, если полей достаточно много или тогда, когда идет ссылание на определенную запись, например с именем.

Нормализация - создание отдельной модели для избежания захламленности основной модели.

Пример
___

Имеется такая модель

|Ученик|Оценка|Учитель|Email
|---|---|---|---
|Сидоров|7|Иванов|ivanov@gmail.com
|Петров|8|Павлов|pavlov@gmail.com

В данной таблице логически хочется разделить учеников и учителей, так как в одной модели слишком много полей. Этот пример дает понимание о каком разделении идет речь. Создайте модель Chields с полями first_name, last_name и score - тут будут оценки. Затем зарегистрируйте модель и настройте нормальное отображение в админке.

|Тип связи|Определение|Примеры
|---|---|---
|Один к одному|Одна запись из главной модели соответствует с одной записью другой модели|Брак, индивидуальный инвестиционный счет
|Много к одному|Одна запись из главной модели соответствует многим записям из другой модели|Автор и статьи, жильцы в доме
|Много к многим|Много записей из главной модели соответствуют многим записям из другой.|Врач и пациенты - у врача может быть много пациентов и у пациента может быть много врачей.

### Связь один к многим

Этот тип связи используется для указания какого-то одного поля для многих записей. Например, если есть таблица с именами учеников и их оценок или же таблица с статьями. У статей может быть заголовок, картинка-превью и основной текст, а так же поле, где указывается автор. Вот как раз тут и прослеживается связь один автор ко многим статьям как и один учитель к мноогим детям в классе.

Связь происходит при помощи поля `ForeignKey`, куда передается имя связываемой модели, а так же параметры `on_delete` и `null=True`.on_delete отвечает за то, какие действия предпринимать при удалении.

Базовый синтаксис связи одного к многим.

```python
class Привязываемая_модель(models.Model):
	поле_1
	поле_2


class Основная_модель(models.Model):
	поле_1
	поле_2
	связывающее_поле=models.ForeignKey(Привязываемая_модель,on_delete=нужное_значение,null=True)
```


После миграций можно увидеть следующее - в основной таблице появилось поле с выпадающим списком, в котором хранятся значения из связываемой таблицы. Для приведения этого в удобочитаемый вид можно как всегда использовать метод str.

**Некоторые значения on_delete**

|Значение|Описание
|---|---
|models.PROTECT|Запись в связуемой таблице можно удалить только в том случае, если она ни к чему не привязана.
|models.CASCADE|При удалении записи из связуемой таблицы удаляются все записи в основной, где была связь.
|models.SET_NULL|При удалении записи из связуемой таблицы все связи в основной модели станут NULL.

#### Работа с шаблоном

В случае с связью один к многим, передача данных в шаблон не составит труда. Если нужно передать данные связуемой таблицы, то обращение к ней идет через связующее поле.

Синтаксис

models

```python
class Связуемая_модель(models.Model):
	поле_2.1
	поле 2.2
class Основная_модель(models.Model):
	поле_1.1
	поле 1.2
	поле_3=models.ForeignKey(Связуемая_модель,null=True,on_delete=models.PROTECT)
```

context

```python
context={
	'ключ':Основная_модель.objects.get(запрос)
}
```

template

```html
<h1>{{ключ.связующее_поле.поле_связуемой_модели}}</h1>
```

### Связь многие к многим

При этом типе связи можно выбрать уже не одно значение, а несколько. Реализация тоже достаточно простая. Тут уже выступает поле `ManyToManyField`, в которое передается связуемая модель.

```python
class Связуемая_модель(models.Model):
	поле_1
	поле_2
class Основная_модель(models.Model):
	поле_1
	поле_2
	поле_3=models.ManyToManyField(Связуемая_модель)
```

Виджет поля можно изменить ы Admin.py, создав класс настроек как и раньше. Используется `filter_horizontal` или `filter_vertical`.

```python
class Основная_модельAdmin(admin.ModelAdmin):
    filter_horizontal=['связывающее_поле']
admin.site.register(models.Основная_модель,Основная_модельAdmin)
```


#### Работа с шаблоном

В этом случае передача данных в шаблон осуществляется немного иначе. Возьмем пример шаблона из связи один к многим, но заменим на ManyToManyField со всеми вытекающими. Шаблон будет выглядеть так.

```html
{%for i in ключ.связывающее_поле.all%}
    <h4>{{i.поле}}</h4>
{%endfor%}
```

### Связь один к одному

Этот тип связи просто объяснить на примере кинотеатра. Есть люди и места. 1 человек - 1 место. Отличие от связи один к многим в том, что если выбираемое значение будет кому-то присвоено, другой записи его присвоить уже не получится. Синтаксис похож.

```python
class Сводная_модель(models.Model):
	поля
class Основная_модель(models.Model):
	поля
	связующее_поле=models.OneToOneField(Places,on_delete=models.SET_NULL,null=True,blank=True)
```

### Программное добавление данных в сводные модели

Для тренировки лучше использовать командную строку.

В связи один к многим для смены значения в связующем поле сначала создается объект записи в сводной модели, а потом он передается в основную, в связующее поле.

```python
from приложение.models import модели
a=Основная_модель.objects.get(запрос) # Запись в основной модели
b=Сводная_модель.objects.get(запрос) # Запись в сводной модели, на которое нужно менять
a.связующее_поле=b
a.save() # Сохранение записи
```

Добавление элементов в связи многие к многим происходит следующим образом. Как и в прошлый раз создается объект записи, которую предстоит изменить, далее создается объект записи сводной таблицы, которую предстоит добавить. Затем при помощи метода `add` передается запись или записи, которые нужно добавить. Метод save применять не нужно.

```python
from приложение.models import модели
a=Основная_модель.objects.get(запрос) # Запись в основной модели
b=Сводная_модель.objects.get(запрос) # Запись в сводной модели, которую нужно добавить
a.связующее_поле.add(b)
```

Для удаления используется метод `remove`.

```python
a.связующее_поле.remove(b)
```



