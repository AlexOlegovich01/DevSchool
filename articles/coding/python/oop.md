# ООП

Затронем тему объектно-ориентированного программирования на языке Python, но общая концепция применима к любому языку программирования.

Все элементы в коде - это объекты. Класс - по сути чертеж или слепок, благодаря которому и создаются объекты. Класс состоит из данных (атрибуты) и поведения данных (методы).

Разберем на простом примере - создадим список. Данные в нем будут значения списка, а поведением - методы, например метод append и так далее.

## Классы встроенных типов

Чтобы узнать класс встроенных типов в Python, используется type(переменная).

```python
print(type('Hello'))
```

Существует еще и проверка на истинность.

```python
isinstance(5,int)
```

В этом примере идет проверка, является ли 4 объектом класса int и, если да, то возвращает True.

## Создание своих классов

```python
# Пример создания пустого класса с именем Car
class Person():
	pass
# Создание экземпляра класса и проверка его типа
a=Person()
print(type(a))
```

## Атрибуты

### Атрибуты класса

Теперь дадим классу несколько атрибутов

```python
class Person():
	name='Alex'
	age=25
```

Чтобы получить значение атрибута, нужно сначала создать экземпляр класса, затеи написать переменную и через точку указать атрибут.

```python
print(a.name)
```

Для того, чтобы получить все атрибуты класса, нужно воспользоваться магическим атрибутом dict.

```python
print(Person.__dict__)
```

Так же можно переопределять атрибуты.

```python
a.name='Ivan'
```

И создавать новые атрибуты.

```python
setattr(Person,'learn',True)
```

Обратите внимание, что атрибут пишется в кавычках, далее идет значение.

Так удаляются атрибуты.

```python
delattr(Person,'age')
```

### Атрибуты экземпляра класса

Поговорим о создании атрибутов для отдельного экземпляра класса.

Создание атрибута

```python
a.learn=True
```

Обратите внимание, что и при изменении атрибута, меняться он будет в конкретном экземпляре класса.

```python
a.age=20
```

Удаление атрибутов

```python
del a.age
```

Можно передать атрибут в качестве функции. Весь класс с ней будет выглядеть так...

```python
class Person():
	name='Alex'
	age=25
	def voice():
		print('Hello, World')
```

Так можно получить аттрибут и вызов функции. Чтобы получить только значение атрибута, нужно убрать пустые круглые скобки.

```python
print(getattr(Person,'voice')())
```

Вызов через функцию выполняется не часто, так как проще работать с методами, которые очень похожи на функции.

## Методы

Метод - это функция, которая объявлена внутри класса и определяющая его поведение. Методы вызываются для конкретных объекта.

 Так можно создавать методы и потом обращаться к ним. Обратите внимание на параметр self. Он указывает на конкретно этот объект.

```python
class Person():
	def voice(self):
		print('Hello, World')
# Создание экземпляра класса и проверка его типа
a=Person()
print(a.voice())
```

Можно передавать параметры как в функции и обращаться к ним, но не забываем, что первым аргументом всегда идет self.

```python
class Person():
	def voice(self,name):
		self.name=name
		print('Hello, World. My name is '+self.name)
a=Person()
print(a.voice('Jerry'))
```

Можно задать значение по умолчанию.

```python
def voice(self,name='Michael'):
```

### Инициализация

Магический метод init служит для инициализации объектов и вызывается сразу при создании объекта. Кроме этого инициализация позволяет обращаться к классу, не обращаясь при этом к методам. Возьмем прошлый пример и немного его переделаем.

```python
class Person():
	def __init__(self,name,gender='Male'):
		self.name=name
		self.gender=gender
		print("Hello, World. My name is "+self.name+". I'm a "+self.gender)	
a=Person('Alexandr','Man')
```

Обратите внимание, что при создании экземпляра класса, сразу же в скобках передаются параметры, один из них указан по умолчанию. Если в примере не написать Man, то в сообщении подставится значение по умолчанию.

### Типы атрибутов

Существуют публичные, защищенные и приватные атрибуты. К публичным атрибутам можно обращаться. Защищенные атрибуты используют перед именем 1 нижнее подчеркивание и к ним обращаться не рекомендуется. А приватные атрибуты имеют 2 нижних подчеркивания перед именем и извне недоступны.

Рассмотрим пример, создадим класс с логином и паролем.

```python
class Person():
	def __init__(self,l='Jeb',p='2131eeew'):
		self.login=l
		self.password=p
	def printing(self):
		print("Ваш логин - {}, а пароль - {}".format(self.login,self.password))
```

Далее создадим экземпляр класса и обратимся к методу printing.

```python
a=Person()
a.printing()
```

Видим, что логин и пароль, которые в этот раз были по умолчанию, отобразились - и это хорошо, но мы можем получить логин и пароль без вызова метода.

```python
print(a.login+' '+a.password)
```

Не всегда хорошо, когда каждый может вот так получить атрибуты вне класса и методов. В этом случае используются приватные атрибуты, а процесс сокрытия их называется инкапсуляцией.

Теперь поставим перед атрибутами 2 нижних подчеркивания. В принте то же самое.

```python
self.__login=l
self.__password=p
```

Теперь невозможно обратиться к атрибутам напрямую, но, вызвав метод можем получить значения.

Но можно сделать приватным и метод, добавив перед названием 2 нижних подчеркивания. И после этого так же вызвать его вне класса будет невозможно.

```python
def __printing(self):
```

## Некоторые магические методы

Магические методы имеют свой функционал и срабатывают в определенный промежуток времени. Один из них был рассмотрен ранее - init. Он вызывается в момент создания экземпляра класса.

### Методы текстового отображения объекта в системе

\__repr__ - отображение экземпляра класса со стороны системы.  
\__str__ - отображение экземпляра класса со стороны пользователя.

#### \__repr__

Разберем пример. При запуска кода, что ниже, увидим информацию об объекте, что не всегда удобно.

```python
class Person():
	def __init__(self,l='Jeb',p='2131eeew'):
		self.__login=l
		self.__password=p
a=Person()
print(a)
```

Теперь объявим метод с \__repr__. При запуске увидим то, что возвращает метод.

```python
def __repr__(self):
	return "Информация о классе"
```

#### \__str__

По сути так же служит для тех же целей. Если после \__repr__ определить метод \__str__, то сработает метод \__str__.

### len и abs

Вспомним про метод len, который возвращает длину строк, списков и так далее. Метод abs возвращает положительное число. len не может работать с числами, а abs - с строками. Так же и экземпляр класса по умолчанию не поддерживает эти методы и, если вызвать их, то выйдет ошибка.

С помощью магических методов можно задать поведение при использовании методов len и abs.

```python
class Person():
	def __init__(self,l='Jeb',p='2131eeew'):
		self.login=l
		self.password=p
	def __len__(self):
		return len(self.password)
a=Person()
print(len(a))
```

Таким образом мы получили длину пароля.

По аналогии используется \__abs__, но уже с числами.

## Наследование

Возможно наследовать методы других классов.

```python
class Cat():
	def myau(self):
		print('Myau')
	def run(self):
		print('Run...')
class Fox(Cat): # Наследование от Cat
	def frrr(self):
		print('Frrr')
foxy=Fox()
foxy.run() # Вызов наследованного метода
```

Так же можно проверить, является ли класс дочерним классу-родителю.

```python
print(issubclass(Fox,Cat)) # Выведет True или False
```

Наследование может быть множественным, то есть можно наследоваться не только от одного родителя, а от нескольких.

```python
class Cat():
	def myau(self):
		print('Myau!')
class Fox():
	def frr(self):
		print('Frr!')
class Animals(Cat,Fox):
	pass
anim=Animals()
anim.myau()
anim.frr()
```

### Переопределение методов

Так же можно переопределить методы - написать метод с тем же именем, но с другим поведением.

```python
class Cat():
	def myau(self):
		print('Myau')
	def run(self):
		print('Run...')
class Fox(Cat): # Наследование от Cat
	def frrr(self):
		print('Frrr')
	def myau(self):
		print('Foxmyau')
foxy=Fox()
foxy.myau()
```

Метод myau наследуется от кота, но мы переопределили этот метод у лисы, и теперь его можно так же вызвать, но он будет выполнять другое действие.

Можно переопределять еще и атрибуты.

```python
class Cat():
	name='Fenix'
	def myau(self):
		print('Myau')
	def run(self):
		print('Run...')
class Fox(Cat): # Наследование от Cat
	name='Alena'
	def frrr(self):
		print('Frrr')
	def myau(self):
		print('Foxmyau')
foxy=Fox()
print(foxy.name)
```

Магические методы тоже можно переопределять.

```python
class Cat():
	def __init__(self):
		print('Я кот!')
class Fox(Cat): # Наследование от Cat
	def __init__(self):
		print('Я лиса!')
foxy=Fox()
```

### Расширение классов

Применимо к дочерним классам.

Extending - создание атрибута или метода,которого нет у родительского класса.

Невозможно родительскому классу наследовать дочерние, но возможно их расширять. Код ниже вызовет ошибку, так как попытка в родителе вызвать метод ребенка не приведет к результату.

```python
class Cat():
	def __init__(self):
		pass
class Fox(Cat): # Наследование от Cat
	def voice(self):
		print('Frrr')
kot=Cat()
kot.voice()
```

Чтобы код заработал, нужно расширить родительский класс, расширив его. Для этого создадим в нем метод, который будет вызывать метод ребенка.

```python
class Cat():
	def __init__(self):
		pass
	def extend(self):
		self.voice()
class Fox(Cat): # Наследование от Cat
	def voice(self):
		print('Frrr')
kot=Fox()
kot.extend()
```

Сначала в родителе был создан метод extend, в котором вызывается метод voice. Далее создается экземпляр класса Fox и вызывается метод extend, который наследуется у Cat.

### Делегирование

```python
class Cat():
	def run(self):
		print('Cat Run!')
class Fox(Cat): # Наследование от Cat
	def run(self):
		print('Fox Run!')
Tom=Fox()
```

Иногда нужновызвать сначала метод дочернего класса, а затем тот же метод родителя. Для этого применяется super.

```python
class Cat():
	def run(self):
		print('Cat Run!')
class Fox(Cat): # Наследование от Cat
	def run(self):
		print('Fox Run!')
		super().run()
Tom=Fox()
Tom.run()
```