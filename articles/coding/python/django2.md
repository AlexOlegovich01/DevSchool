# Django. Часть 2

Здесь рассмотрим материал по Django немного под другим углом. Этот материал - не замена предыдущего. Его можно считать его дополнением и не считать таковым - это иной взгляд на то, что уже было написано, так что этот материал лучше рассматривать после освоения предыдущего.

Мы создадим сайт с несколькими приложениями, но двигаться будем быстрее. Приступим. Создадим проект с именем Project_01 и в нем создадим приложение ItemsWiki - в нем будет краткая информация об инструментах из игры Minecraft.

## Что такое приложение на примере некоторых сайтов?

Приложение - это структурная единица сайта, которая выполняет определенную функцию. Так есть сайт Гугл или Яндекс, например, но у этих сайтов есть разделы, к примеру Гугл переводчик или Яндекс Такси - именно эти разделы можно считать приложениями, так как Django позволяет разбить сложный проект на простые составляющие, которые можно включать и отключать и это - приложения.

## urls.py и views.py

Эти 2 файла имеют важное значение в разработке сайта. В urls.py заносятся все веб-страницы, которые есть на сайте, а в views.py записывается логика этих страниц, которая называется контроллерами. Самая простая задача контроллера - рендер или по простому - отображение страницы.

В первой статье был метод HttpResponse, который перенаправлял пользователя на стартовую страницу. В этот раз рассмотрим немного другой вариант использования этого метода - вывод произвольного текста на экран.

ItemsWiki/views.py

```python
from django.shortcuts import render
from django.http import HttpResponse 
def lopata(request):
	return HttpResponse('Нужна для копания и создания дорожек')
def kirka(request):
	return HttpResponse('Нужна для добычи ресурсов')
def topor(request):
	return HttpResponse('Нужен для рубки деревьев и древесины, а так же можно использовать как оружие')
def mech(request):
	return HttpResponse('Оружие ближнего боя')
def motyga(request):
	return HttpResponse('Нужна для вспахивания земли')
```

urls.py

```python
from django.contrib import admin
from django.urls import path
from ItemsWiki import views
urlpatterns = [
    path('admin/', admin.site.urls),
	path('lopata/',views.lopata),
	path('kirka/',views.kirka),
	path('topor/',views.topor),
	path('mech/',views.mech),
    path('motyga/',views.motyga),
]
```

Обратите внимание на то, что мы избавились от большого "поезда" импортированных модулей, импортировав views и обращались к контроллерам через точку.

Теперь можно запустить сервер и пройтись по созданным адресам, например, перейти по адресу http://127.0.0.1:8000/kirka/ . На главной странице ошибка из-за того, что она не была создана, но это поправим позже.

## Переменные среды

Поскольку у нас есть приложение ItemsWiki, логично хранить url адреса, связанные с ним, в нем. Представьте, что вы делаете сайт, у которого 20 приложений и у каждого приложения примерно по 50 ссылок - крайне неудобно хранить все ссылки в одном месте, поэтому мы их распределим.

В приложении нужно создать файл urls.py, далее перейти в главный urls.py и переместить в файл приложения переменную с ссылками, удалив ненужное - ссылку на админку и импортировав нужные модули.

urls.py

```python
from django.contrib import admin
from django.urls import path,include
from ItemsWiki import views
urlpatterns = [
    path('admin/', admin.site.urls),
	path('itemswiki/',include('ItemsWiki.urls')),
]
```

ItemsWiki/urls.py

```python
from django.contrib import admin
from django.urls import path,include
from ItemsWiki import views
urlpatterns = [
    path('admin/', admin.site.urls),
	path('itemswiki/',include('ItemsWiki.urls')),
]
```

Обратите внимание на точку в импорте - так идет импорт из папки, в которой лежит файл.

## Динамические urls

Но можно избавиться от кучи контроллеров и urls, создав 1 контроллер и 1 url с помощью параметров. Параметр - это по сути переменная, которую можно свободно использовать.

Для реализации этого нужно перейти в urls.py в папке приложения, хотя можно перейти и в основной urls, но так делать не рекомендуется.

```python
urlpatterns = [
    path('<item>/',views.item),
]
```

Здесь item - параметр, который помещается в теговые скобки.

В контроллере параметр передается вторым после request. Теперь можно удалить все лишние urls и контроллеры - создадим один контроллер, в котором будем обращаться к переменной.

```python
def item(request,item):
	if item=='lopata':
		return HttpResponse('Нужна для копания и создания дорожек')
	elif item=='kirka':
		return HttpResponse('Нужна для добычи ресурсов')
	elif item=='topor':
		return HttpResponse('Нужен для рубки деревьев и древесины, а так же можно использовать как оружие')
	elif item=='mech':
		return HttpResponse('Оружие ближнего боя')
	elif item=='motyga':
		return HttpResponse('Нужна для вспахивания земли')
	else:
		return HttpResponse('Страница не доступна')
```

Или так

```python
def item(request,item):
	urls_dict={
		'lopata':'Нужна для копания и создания дорожек',
		'kirka':'Нужна для добычи ресурсов',
		'topor':'Нужен для рубки деревьев и древесины, а так же можно использовать как оружие',
		'mech':'Оружие ближнего боя',
		'motyga':'Нужна для вспахивания земли',
	}
	for k,v in urls_dict.items():
		if item==k:
			return HttpResponse(v)
	else:
		return HttpResponse('Страница не доступна')
```

Или так. Обратите внимание, что словарь можно передать и вне функции. Ниже идет обращение к методу get, который возвращает значение ключа или None, если ключа не существует.

```python
urls_dict={
		'lopata':'Нужна для копания и создания дорожек',
		'kirka':'Нужна для добычи ресурсов',
		'topor':'Нужен для рубки деревьев и древесины, а так же можно использовать как оружие',
		'mech':'Оружие ближнего боя',
		'motyga':'Нужна для вспахивания земли',
	}
def item(request,item):
	desc=urls_dict.get(item,None)
	if desc:
		return HttpResponse(desc)
	else:
		return HttpResponse('Страница не доступна')
```

### Конвертеры

На некоторых сайтах помимо обычных ссылок есть ссылки с числами, например

```
сайт/приложение/1
сайт/приложение/2
сайт/приложение/3
```

Вернемся к нашему примеру. Мы не можем напрямую задать условие, если запрос будет равен 1, то переводить на страницу. Можно конечно число заключить в строку и тогда все получится, но это лишает нас многих возможностей. Для того, чтобы контроллер понимал числа, есть числовой контроллер. Это можно воспринимать как если бы мы переводили число в строку или наоборот. Кроме числовых конвертеров есть и другие, но мы разберемся на примере чисел.

views.py

```python
def intitem(request,item):
	if item==5:
		return HttpResponse('Вы ввели волшебное число!')
```

ItemsWiki/urls.py

```python
path('<int:item>/',views.intitem),
```

Попробуем перейти по адресу http://127.0.0.1:8000/itemswiki/5/ , чтобы увидеть, что все работает.

### Перенаправление

Вернемся к приложению с инструментами и допустим, что мы хотим, чтобы страницы были доступны не только по названию инструмента, но и по порядковому номеру в словаре. Для перенаправления используется метод HttpResponseRedirect.

```python
from django.http import HttpResponse,HttpResponseRedirect
...
def item_response(request,item):
	if item==5:
		return HttpResponseRedirect('https://www.google.com/')
	else:
		return HttpResponse('Страница не доступна')
```

Теперь, если перейти по адресу http://127.0.0.1:8000/itemswiki/5, то перенаправит в гугл.

### Reverse и name

В нашем коде есть моменты, где явно указывается на название приложения, когда это и так понятно. Понятное дело, что при переходе на страницу с киркой, например, в адресной строке будет itemswiki, но он встречается у нас 2 раза в коде - первый раз в пространстве имен, а второй раз при редиректе. Чтобы не обращаться явно, в urls.py, который в приложении, можно передать имя после указания контроллера.

```python
path('<item>/',views.item,name='items'),
```

Обратите внимание, что нужно импортировать еще один модуль и на то, что в reverse передается 2 параметра. Первый обязательный - имя, которое было дано в urls.py, а второй параметр - кортеж, в который нужно передать то, что будет идти после слеша. Поскольку это кортеж и передается в нем одно значение, нужно поставить запятую.

```python
def item(request,item):
	desc=urls_dict.get(item,None)
	if desc:
		return HttpResponse(desc)
	if item=='555':
		return HttpResponseRedirect(reverse('items',args=('kirka',)))
	else:
		return HttpResponse('Страница не доступна')
```

## Шаблоны и статика

html страницы будут называться шаблонами. Статика - статические данные, стили, скрипты и так далее.

Шаблоны хранятся в папках templates. Они создаются в папках приложений. В папке templates создается папка, которая имеет такое же имя как у приложения и уже в этой папке создаются шаблоны.

Создадим шаблон index.html.

```html
<body>
	<h1>Инструменты</h1>
</body>
```

Открыть views.py и добавим в него новый контроллер и воспользуемся методом render для отрисовки шаблона.

```python
def mainitems(request):
	return render(request,'ItemsWiki/index.html')
```

Добавить контроллер в urls.py. Тут имя можно задать любое.

```python
path('',views.mainitems,name='mainitems'),
```

При переходе на http://127.0.0.1:8000/itemswiki

### Динамические страницы

В html код можно передать данные из написанного кода.

Это можно сделать из контроллера, добавив 3 параметром в render переменную с словарем. Делается это следующим образом. В контроллере создается переменная, которая хранит в себе словарь и передается 3 параметром в render.

views.py

```python
def mainitems(request):
	context={
		"title1":"Инструменты",
		"title2":"Предметы",
		"title3":"Другой заголовок",
	}
	return render(request,'ItemsWiki/index.html',context)
```

Чтобы обратиться из httmlдокумента к словарю, нужно заключить ключ в двойные фигурные скобки. Если после этого перейтипо адресу, то в заголовке будет значение переданного ключа.

index.html

```html
<h1>{{title2}}</h1>
```

Если в словаре есть вложенные словари, то обращение к ним идет через точку.

### Условия

Можно вызвать в шаблоне.

Пример условия

```html
{%if условие%}
	html код
{%else%}
	html код
{%endif%}
```

В условиях переменные не заключаются в двойные фигурные скобки. Так же обязателен синтаксис оборота в одинарные фигурные скобки и в проценты. Условие завершается блоком endif.

### Цикл for

Синтаксис похожий.

```html
{%for переменная-счетчик in переменная%}
	html код {{переменная-счетчик}}
{%endfor%}
```

Пример. Создадим меню на нашем сайте, изменив context и добавив условие в шаблон.

```python
context={
	"hrefbank":["Лопата","Кирка","Топор","Меч","Мотыга",],
}
```

```html
<body>
	{%for href in hrefbank%}
		<div><a href="">{{href}}</a></div>
	{%endfor%}
</body>
```

 Войдя на адрес страницы, увидим меню.
 
 ### Тег url
 
 Тег url используется в гиперссылках для ссылания на код. Аналог метода reverse.
 
 Для того, чтобы все заработало, сначала нужно в urls.py, который в приложении прописать переменную app_name, в которую передать строкой название приложения. 
 
 Вот синтаксис.
 
 ```html
 <a href="{%url 'имя приложения:имя url'%}">Ссылка</a>
 ```
 
 Часто нужно перебрать в цикле и обращаться по id, для формирования ссылки. Для этого есть дополнительные параметры, которые нужно указать в теге url.
 
  ```html
 <a href="{%url 'имя приложения:имя url' второй_аргумент_контроллера=итер%}">Ссылка</a>
 ```
 
 Пример.
 
 В шаблоне создать ссылку, которая будет вести в другой контроллер. Там может быть все, что угодно, но для примера воспользуемся HttpResponse.
 
 views.py
 
 ```python
def hiper(request):
	return HttpResponse("Вы перешли по ссылке")
```

Далее добавить контроллер в urls как обычно. Перейти в index.html

```html
<body>
	<a href="{%url 'itemswiki:hiper'%}">Ссылка</a>
</body>
```

### Наследование

Часто бывает так, что в сайте многие элементы на странице дублируются. Это может быть заголовок, меню, футер или другие элементы. В программировании дублирование - плохо, так как идет в разрез с оптимизацией, поэтому используется наследование.

Суть такова, что будет 1 шаблон base.html, в котором будет все, что повторяется и другие страницы, которые будут наследоваться от него. В base.html хранится все, кроме уникальных элементов. Если они есть, то нужно их вырезать и добавить вместо них тег следующего формата.

```html
{%block название%}{%endblock%}
```

Далее в наследуемые страницы добавляется специальный тег extends, в который передается путь до базового шаблона, а уже потом добавляются теги с уникальным кодом, как показано ниже.

```html
{%block название%}
	html код
{%endblock%}
```

Пример
___

Создать сайт с статьями про инструменты из Minecraft. Для этого создадим html файлы с именами index, lopata, kirka, topor, mech, motyga,base. В шаблонах будет меняться заголовки и статьи.

Перейдем в views.py и создадим там контроллер. Для наглядности я не оптимизировал

```python
def items(request,item):
	if item=='index':
		return render(request,'itemswiki/index.html')
	if item=='lopata':
		return render(request,'itemswiki/lopata.html')
	if item=='kirka':
		return render(request,'itemswiki/kirka.html')
	if item=='topor':
		return render(request,'itemswiki/topor.html')
	if item=='mech':
		return render(request,'itemswiki/mech.html')
	if item=='motyga':
		return render(request,'itemswiki/motyga.html')
```

Добавить ссылку в urls.py.

```python
path('<item>/',views.items,name='items'),
```

base.html

```html
<body>
	{%block title%}{%endblock%}
	<div class="items">
		<div class="item"><a href="{%url 'itemswiki:items' item='lopata'%}">Лопата</a></div>
		<div class="item"><a href="{%url 'itemswiki:items' item='kirka'%}">Кирка</a></div>
		<div class="item"><a href="{%url 'itemswiki:items' item='topor'%}">Топор</a></div>
		<div class="item"><a href="{%url 'itemswiki:items' item='mech'%}">Меч</a></div>
		<div class="item"><a href="{%url 'itemswiki:items' item='motyga'%}">Мотыга</a></div>
	</div>
	{%block article%}{%endblock%}
</body>
```

```html
index.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Инструменты</h1>
{%endblock%}


kirka.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Кирка</h1>
{%endblock%}
{%block article%}
	<p>Нужна для добычи ресурсов</p>
{%endblock%}


lopata.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Топор</h1>
{%endblock%}
{%block article%}
	<p>Нужен для рубки деревьев и древесины, а так же можно использовать как оружие</p>
{%endblock%}


mech.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Меч</h1>
{%endblock%}
{%block article%}
	<p>Оружие ближнего боя</p>
{%endblock%}


lopata.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Лопата</h1>
{%endblock%}
{%block article%}
	<p>Нужна для копания и создания дорожек</p>
{%endblock%}


motyga.html

{%extends 'ItemsWiki/base.html'%}
{%block title%}
	<h1>Мотыга</h1>
{%endblock%}
{%block article%}
	<p>Нужна для вспахивания земли</p>
{%endblock%}
```

Обратите внимание на index.html - в нем не была передана статья и все равно все работает. То есть если тег пустой, то ничего страшного.

### Тег include

Этот тег позволяет вынести части html кода в отдельные файлы и обращаться к этим файлам сколько угодно раз. Синтаксис такой...

```html
{%include 'путь к файлу'%}
```

В папке templates можно создать папку с инклудами и уже с ней работать.

Пример

___

Используем предыдущий пример из части про наследование. В base.html есть блок items. Вырежем его, создадим в папке templates папку includes и уже там создадим шаблон - назовем его include.html и вставим в него вырезанный блок.

include.html

```html
<div class="items">
	<div class="item"><a href="{%url 'itemswiki:items' item='lopata'%}">Лопата</a></div>
	<div class="item"><a href="{%url 'itemswiki:items' item='kirka'%}">Кирка</a></div>
	<div class="item"><a href="{%url 'itemswiki:items' item='topor'%}">Топор</a></div>
	<div class="item"><a href="{%url 'itemswiki:items' item='mech'%}">Меч</a></div>
	<div class="item"><a href="{%url 'itemswiki:items' item='motyga'%}">Мотыга</a></div>
</div>
```

base.html

```html
<body>
	{%block title%}{%endblock%}
	{%include 'includes/include.html'%}
	{%block article%}{%endblock%}
</body>
```

### Переменная content

С помощью этой переменной можно передать нужные значения в контроллер. Имя переменной может быть любым, но по стандарту ее называют content. Именно с помощью этой переменной можно передавать значения из бэкенда в шаблоны. В content передается словарь.

Синтаксис

В контроллере

```python
context={
    'ключ':'значение'
}
return render(request,'путь к шаблону',context)
```

В шаблоне

```html
<body>
    <h1>{{title}}</h1>
</body>
```

Если в качестве значений выступают другие словари, то к ним обращаются через точку.


























## Базы данных

Подготовка таблиц для базы данных производится в файле models.py, который находится в созданном приложении. Подготовка таблицы происходит путем создания класса, который наследуется от джанговского класса. В созданном классе можно простым способом передать поля и типы полей, которые будут в таблицах базы данных. Модели - это те же таблицы в базах данных.

Синтаксис

```python
class ИмяТаблицы(models.Model):
	Поле1=models.ТипПоля(параметры)
	Поле2=models.ТипПоля(параметры)
```

### Миграции

Миграции переводят классы в базы данных SQL. Если запускать сервер, он запустится, но можно увидеть, что выводится сообщение о непримененных миграциях.Для начала в консоли, в папке, откуда запускается сервер, нужно ввести следующее...

```
manage.py makemigrations
```

После ввода команды можно увидеть, что были созданы миграции для ранее созданного класса. Так же был создан файл миграции в папке migrations - этот файл как раз и переводит из формата класса в формат таблицы в базе данных. Теперь надо применить миграции. Для этого ввести

```
manage.py migrate
```

Для просмотра базы данных можно использовать программу SQLite Studio. Напомню, что база данных расположена в корне и называется db.sqlite3. При открытии можно увидеть много таблиц, среди которых есть и свежие модели.

### Работа с полями базы данных

Есть 2 способа взаимодействовать с БД - при помощи консоли и при помощи админ-панели.

Для первого способа нужно сделать следующее - открыть терминал и в корне, вписать следующее

```
manage.py shell
```

Таким образом можно попасть в обычную питоновскую консоль. Далее введем

```
from приложение.models import Название модели
```

Запись создается таким образом...

```
ИмяМодели.objects.create(поле=значение,поле=значение)
```

Для просмотра таблицы используется метод all(), но перед его применением нужно внести изменения в класс таблицы, добавив магический метод \__str\__, иначе информация выводиться будет, но не та, что надо. В этом методе нужно прописать те поля, которые мы хотим видеть. Эти же поля будут отображаться и в админ панели. Можно использовать конкатенацию.

```python
def __str__(self):
	return self.поле
```

`ВАЖНО!  
При определении новых методов в классе база данных никак не меняется, но если вносить изменения в настройки полей, то нужно заново создавать и применять миграции.`

Выборка по значению поля

```
ИмяМодели.objects.filter(поле=значение)
```

Или

```
ИмяМодели.objects.get(поле=значение)
```

Получить конкретное поле

```
ИмяМодели.objects.get(поле=значение).поле
```

### Передача значений из БД в шаблон

В контроллере создать переменную context, которая является словарем.

```python
context={
    'movie':MoviesTable.objects.all()
}
```

Поскольку база данных состоит из нескольких значений, их нужно перебрать в цикле for в шаблоне.

```html
{%for итер in ключ_словаря_с_бд%}
    <h1>{{итер.поле}} {{итер.поле}}</h1>
{%endfor%}
```

Пример

___

Имеется база данных с фильмами.

|id|name|genre|year
|---|---|---|---
|1|Matrix|fantastic|1999
|2|SAW|horror|2004

Цель - вывести список фильмов в шаблоне.

Для начала создать модель.

models.py

```python
class MoviesTable(models.Model):
	name=models.CharField(max_length=20)
	genre=models.CharField(max_length=20)
	year=models.IntegerField()
```

Прописать в приложении, в urls.py, путь. Пусть он будет без лишних элементов.

urls.py

```python
path('', views.films),
```

Создать контроллер

views.py

```python
def films(request):
    context={
        'movies':MoviesTable.objects.all()
    }
    return render(request,'movies/films.html',context)
```

В шаблоне прописать

```html
<body>
    {%for mv in movies%}
        <a href=""><h1>{{mv.name}}</h1></a>
    {%endfor%}
</body>
```

Запустив сервер и перейдя по ссылке, увидим список фильмов, но давайте создадим еще один шаблон, в котором будет просто название фильма, его жанр и год выпуска. Шаблон назовем film.html.

film.html

```html
{%extends 'movies/base.html'%}
{%block body%}
    <h1>{{movie.name}}</h1>
    <h2>Жанр - {{movie.genre}}</h2>
    <h2>Год - {{movie.year}}</h2>
{%endblock%}
```

Создать контроллер, который будет принимать второе значение - числовой конвертер. Хотелось бы назвать второй параметр - id, но это имя зарезервировано в Python, поэтому его использовать в качестве имени нельзя, поэтому назовем его num.

views.py

```python
def film(request,num:int):
    context={
        'movie':MoviesTable.objects.get(id=num)
    }
    return render(request,'movies/film.html',context)
```

Итак, теперь есть 2 контроллера - films, который отвечает за главную страницу и film, который выводит информацию о фильме по его id. Осталось добавить путь.

```python
path('movies/<int:num>', views.film,name='film'),
```

Чтобы перейти к нужному фильму, нужно перейти соответственно по ссылке. Ссылки будут в таком формате, исходя из ранее написанного кода. Тут 1 и 2 - id фильмов.

```
http://127.0.0.1:8000/movies/1
http://127.0.0.1:8000/movies/2
```

А теперь надо как-то передать id в гиперссылки на главной странице. Вспомним про name в путях. Используя имя, можно передать его в качестве ссылки, а вторым параметром передать id, все остальное сделает цикл for.

films.html

```html
{%for mv in movies%}
    <a href="{%url 'movies:film' num=mv.id%}"><h1>{{mv.name}}</h1></a>
{%endfor%}
```

### Слаги

Слаги - это удобочитаемые данные, которые могут быть переданы в ссылки, как id и другое.

Добавить поле для слагов в модель и прописать значение по умолчанию так как поле добавляется уже после того, как были внесены записи и django не знает чем заполнить его и отключим NULL.

models.py

```python
slug=models.SlugField(default='',null=False)
```

Создать и применить миграцию.

Теперь нужно заполнить slug поле значениями. Можно конечно это делать вручную, но если там не 2 записи, а десятки тысяч, то это уже перестает быть хорошей идеей, поэтому мы можем импортировать метод для работы с слагами и переопределить метод save в модели.

```python
from django.utils.text import slugify
...
def save(self,*args,**kwargs):
    self.имя_слаг_поля=slugify(self.имя_поля)
    super(имя_модели,self).save(*args,**kwargs)
```

Теперь надо сделать так, чтоб у всех имеющихся записей появился slug. Для этого находим контроллер, к которому есть быстрый доступ и создаем новую переменную, значение которой будет вся таблица, а после просто перебираем ее в цикле. По сути, если в контроллере уже есть objects.all() то можно созданную переменную подставить в значение словаря, где это уместно.

```python
переменная=название_модели.objects.all()
for i in переменная:
    i.save()
```

При запуске сервера и переходе на страницу с контроллером цикл выполнится, и слаги будут подставлены во все поля автоматически. Новую переменную и цикл можно, но не обязательно удалять.

Осталось поработать с ссылками и путями. Перейти в urls.py приложения и заменить путь с именем film.

```python
path('<slug:второй_параметр_контроллера>', views.имя_контроллера,name='имя_пути'),
```

Далее в контроллере тип второго параметра выставить в str, в objects.get изменить выборку. Контроллер будет выглядеть так.

```python
def имя_контроллера(request,имя второго параметра:str):
    context={
        'имя_ключа':имя_модели.objects.get(slug_поле=имя_второго_параметра)
    }
    return render(request,'путь_к_шаблону',context)
```

**Обратите внимание, что в контроллере тип str, а в путях - slug.**

Шаблон

```html
{%for итер in имя_ключа%}
    <a href="{%url 'имя_пути' второй_параметр=итер.поле%}"><h1>{{итер.поле}}</h1></a>
{%endfor%}
```

### Сортировка и агрегации

Методы сортировки аналогичны методу all(), но сортируют выдачу по определенному полю. Если перед полем поставить минус, то произойдет инверсия.

Сортировка

```python
имя_модели.objects.order_by('поле')
```

Инверсия

```python
имя_модели.objects.order_by('-поле')
```

Срез - показывает ограниченное число

```python
имя_модели.objects.order_by('-поле')[:число]
```

Агрегации - это операции с данными такие как суммирование, нахождение максимума или минимума и так далее.

Для начала нужно импортировать нужные модули в views.py, далее в нужном контроллере создается новый ключ с значением, которое и является агрегацией. Существует несколько агрегирующих функций - Sum - сумма, Min - минимальное значение, Max - максимальное значение, Avg - среднее арифметическое, Count - количество.

Базовый синтаксис

```python
from django.db.models import Sum, Max, Min, Count,Avg
...
context={
    'ключ':имя_модели.objects.all().aggregate(функция_агрегации('поле'))
}
```

Далее можно вызвать в шаблоне. Чтобы узнать ключ, можно воспользоваться консолью.

```python
from приложение.models import имя_модели
from django.db.models import Sum, Max, Min, Count,Avg
print(имя_модели.objects.all().aggregate(агрегирующая_функция('поле')))
```

Таким образом можно получить ключ и значение, но шаблону нужен только ключ и через точку его можно передать как обычно.

## Админ-панель

Админ-панель многим удобна, например, в ней можно удобно добавлять новые записи в базы данных. Админка доступна по адресу `http://127.0.0.1:8000/admin`. Если сейчас в нее перейти, то попросит ввести логин и пароль, но пока что в проекте нет суперпользователя - главного админа, поэтому его нужно создать в консоли, прописав там `manage.py createsuperuser`. После этого придумать логин, далее ввести электронную почту, но можно это пропустить нажав Enter и ввести пароль. Теперь можно использовать эти данные для входа в админку.

Но в ней нет нами созданной модели - ее нужно зарегистрировать в файле приложения admin.py.

```python
from django.contrib import admin
from . import models
admin.site.register(models.имя_модели)
```

Чтобы записи отображались в удобочитаемом виде, в модель нужно добавить метод str.

```python
def __str__(self):
	return self.поле
```

### Основные настройки админки

Для смены языка перейти в settings.py и укажите нужный в `LANGUAGE_CODE = 'ru-RU'`.  
Для кастомизации заголовка нужно перейти в главный urls.py и ввести там не в путях `admin.site.site_header='Кастомный заголовок'`.  
Для кастомизации подзаголовка нужно в главном urls.py прописать `admin.site.index_title='Подзаголовок'`.

### Настройки отображения полей

При переходе в админку и созданную модель можно увидеть неудобочитаемые записи. Даже при добавлении метода ыек в модель ситуация становится не особо лучше так как вроде бы и выводятся нужные данные, но все равно это не красиво - хотелось бы отображать их в табличном виде.

Сначала нужно перейти в admin.py и создать там класс, который принято называть как имя модели, но после приписывать Admin. В классе определить специальную переменную `list_display` и передать в нее список полей, которые нужно отобразить в админке. После этого там, где была регистрация модели, через запятую указать имя новосозданного класса.

```python
from django.contrib import admin
from . import models
class имя_моделиAdmin(admin.ModelAdmin):
    list_display=['поле1','поле...']
admin.site.register(models.имя_модели,имя_моделиAdmin)
```

Так же можно и редактировать записи не переходя по ним, но заранее отмечу, что элементы, по которым нужно кликать, нельзя так менять - нужно перейти по ним и уже потом редактировать. Для редактирования негиперссылковых моделей в ранее созданном классе прописывается еще одна переменная`list_editable`, в которую передается список полей на редактирование.

Примечание!  
Первый элемент списка list_display всегда будет кликабельным.

Сортировка в админке тоже очень простая - достаточно кликнуть по названию поля, но при таком способе меняется адрес страницы и если вернуться обратно, то сортировка сбросится. Чтобы такого не было можно указать еще один список`ordering`, в который передаются поля для сортировки. Тут все как и при обычной сортировке.

За количество отображаемых записей на странице отвечает переменная `list_per_page`, в которую уже передается не список, а целое число.

### Choices поля

Choices поля - это CharField поля с выпадающим списком, из которого можно выбрать 1 вариант. Может быть полезен для указания пола или жанра фильма.

Изменения будут происходить в файле models.py. Сначала, в модели над полями, создается список с картежами. Каждый кортеж - вариант выбора. В картеже 2 значения, первое - условное обозначение, которое хранится в базе данных, а второе значение - собственно вариант выбора. Далее создается CharField поле с нужными параметрами: `max_length=1` говорит о том, что будет выбрано только одно значение; `choices=переменная` - сюда передается название списка; `default=''` - значение по умолчанию. Значение по умолчанию - первый элемент в списке. После всех действий с моделью нужно создать и применить миграцию.

### Поисковое поле в админке

Для добавления строки поиска нужно в admin.py, в классе прописать еще одну переменную `search_fields`, в которую передается список полей, по которым будет осуществляться поиск.

### Фильтры в админке

Для добавления фильтров нужно в ранее созданном классе прописать переменную `list_filter`, в которую передать список полей, по которым нужно фильтровать. При переходе в админку появится панель с фильтром.

Обратите внимание, что в фильтры выводятся все уникальные значения, но это не всегда удобно. Например, при создании интернет магазина будет поле с ценами и уникальных значений там очень много, поэтому можно объединить их в диапазоны, например с низкими ценами, средними и высокими.

Создать новый класс в admin.py и прописать туда 2 переменные. `title` - заголовок фильтра, который будет отображаться в фильтре. `parameter_name` - значение будет отображаться в адресной строке при переходе к фильтру.

```python
class Название(admin.SimpleListFilter):
    title='Заголовок фильтра'
    parameter_name='Указатель в url адресе - что угодно'
```

Далее в этом же классе создается метод `lookups`, который принимает значения `request` и `model_admin`. Пока что метод возвращает список из кортежей - первое значение кортежа отображается в адресной строке, а второе - название ссылки в фильтре, например ссылка Низкие цены.

```python
def lookups(self, request,model_admin):
    return [
        ('отображается в url','название ссылки в фильтре'),
        ('отображается в url','название ссылки в фильтре'),
    ]
```

Далее переопределить метод queryset. Пока что пусть возвращает queryset.

```python
def queryset(self, request, queryset:QuerySet):
    return queryset
```

Далее перейти к переменной list_filter и передать в список имя созданного класса. Обратите внимание, что ранее созданный класс должен быть выше класса с настройками, так как код читается сверху вниз.

теперь при переходе в админку и при нажатии на ссылки фильтра можно увидеть как меняется адресная строка, но значения модели не меняются. Чтобы это исправить, нужно разобраться, какая переменная отвечает за подставление значения из кортежей в адресную строку и с помощью условия произвести действие с моделью. Такой переменной является value, но поскольку она является частью класса, ее нужно вызывать как self.value.

```python
def queryset(self, request, queryset:QuerySet):
    if self.value()=='отображаемое_в_url':
        return queryset.filter(запрос_сравнения)
```

### Настройка форм админки

При клике на запись в админке, перекидывает в форму.

Для того, чтобы исключить какое-нибудь поле, например поле с слагами, нужно как и раньше прописать переменную `exclude`, которая содержит список с исключенными полями. Это действие никак не влияет на модель.

Для запрета редактирования поля можно прописать переменную `readonly_fields`, которая хранит список с полями.

## Связи моделей

Данные целесобразно хранить в разных моделях в том случае, если полей достаточно много или тогда, когда идет ссылание на определенную запись, например с именем.

Нормализация - создание отдельной модели для избежания захламленности основной модели.

Пример
___

Имеется такая модель

|Ученик|Оценка|Учитель|Email
|---|---|---|---
|Сидоров|7|Иванов|ivanov@gmail.com
|Петров|8|Павлов|pavlov@gmail.com

В данной таблице логически хочется разделить учеников и учителей, так как в одной модели слишком много полей. Этот пример дает понимание о каком разделении идет речь. Создайте модель Chields с полями first_name, last_name и score - тут будут оценки. Затем зарегистрируйте модель и настройте нормальное отображение в админке.

|Тип связи|Определение|Примеры
|---|---|---
|Один к одному|Одна запись из главной модели соответствует с одной записью другой модели|Брак, индивидуальный инвестиционный счет
|Много к одному|Одна запись из главной модели соответствует многим записям из другой модели|Автор и статьи, жильцы в доме
|Много к многим|Много записей из главной модели соответствуют многим записям из другой.|Врач и пациенты - у врача может быть много пациентов и у пациента может быть много врачей.
