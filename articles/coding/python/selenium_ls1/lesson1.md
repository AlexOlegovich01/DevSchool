# Введение в Selenium
Selenium - один из лучших инструментов, который можно использовать при парсинге сайтов. Его главным преимуществом для нас будет  имитация реального пользователя. Таким образом можно автоматизировать сбор данных с сайтов, несмотря на их системы защиты против роботов.  

К сожалению не на всех сайтах удается беспрепятственно парсить данные даже с этим замечательным модулем, но в основном со своей задачей он справляется хорошо.  

## Приступаем к делу
Для работы с Selenium нужен вебдрайвер. Это специальная программа, которая имитирует работу браузера. Да мы, собсвенно и будем посещать сайты с браузера, но в автоматическом режиме.  

Но сначала нужно его скачать. Есть версия **Chromedriver** под [Chrome](https://chromedriver.chromium.org/downloads) и **Geckodriver** под [Firefox](https://github.com/mozilla/geckodriver/releases). Сразу скажу, что желательно использовать Geckodriver, потому что его можно очень гибко настроить под свои нужды, поэтому дальше будем разбирать примеры, используя Geckodriver. Скачивайте под свою версию браузера или близкое к ней.  

Теперь можем установить сам Selenium при помощи pip

```
pip install selenium
```
А теперь, когда все нужные файлы скачаны и Selenium установлен, мы можем приступать к написанию кода. Сначала рассмотрим базовые понятия и скелет программы, а потом спарсим данные с какого-нибудь сайта.  

**Файл с вебдрайвером должен быть в той же папке, что и программа.**

```python
#Скелет программы
from selenium import webdriver
import time #Для имитации задержки
options=webdriver.FirefoxOptions() #Создаем объект настроек
driver=webdriver.Firefox(options=options) #Создаем объект вебдрайвера и подключаем опции
try:
	driver.get('url') #Попадаем на нужный сайт
	tine.sleep(10) #Ждем 10 секунд
except:
	pass
finally:
	driver.close() #Закрывает окно
	driver.quit() #Полностью закрывает вебдрайвер
```
Крайне важно следовать именно такому скелету с попытками отлова ошибок. Сначала программа пытается попасть на нужный сайт. Если все хорошо, программа заходит на сайт и, через 10 секунд, переходит в блок finally, где идет закрытие вебдрайвера. Если же что-то пошло не так, программа входит в блок except и, учитывая, что там ничего нет, сразу же закрывает ведрайвер.  

А нужно это для того, чтобы незакрытые вебдрайвера не оставались в оперативной памяти. Это еще хорошо, если мы просто можем закрыть окно, но мы будем работать и в фоновом режиме вебдрайвера, где вход на сайт и все действия на нем будут производиться в фоновом режиме. Так-то можно конечно закрыть из Диспетчера задач, но зачем вам лишняя головная боль?  

[:rewind:**Вернуться назад**](../../../../README.md)