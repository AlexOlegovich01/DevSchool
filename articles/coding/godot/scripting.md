# Скриптинг в Godot

Для добавления скрипта на объект, нужно щелкнуть по нужной ноде и нажать на значок свитка Прикрепить скрипт. Далее нужно выбрать язык программирования и путь, где будет находиться скрипт.

## Про GDScript

Язык очень похож на Python.

При создании скрипта можно увидеть 2 метода. `_ready` выполняется при старте игры. `_process` выполняется каждый кадр.

Чтобы напечатать что-либо в лог

```
print(Содержимое)
```

Чтобы переместить объект на заданные координаты можно воспользоваться position. Название многих свойств есть в инспекторе, если подержать курсор мыши на нужном свойстве, всплывет подсказка с названием свойства.

```
func _ready():
	position=Vector2(0,0)
```

Определить переменную можно при помощи var или const, если переменная не будет изменяться.

```
var переменная=значение
или
var переменная: тип=значение
```

Для определения массива

```
var название Array[тип]=[значение, значение...]
```


## Связка разных нод

Часто бывает нужно связать несколько нод в одном скрипте. Например, нужно получить координаты бонуса, когда скрипт висит на игроке. Делается это очень просто - нужно просто перетащить нужную ноду прямо в скрипт и дописать нужное свойство. Например у нас есть нода person и есть нода bonus. Прикрепим скрипт на person и в методе `_ready` узнаем координаты бонуса.

```
func _ready():
	print($"../bonus".position)
```


## Условия и циклы

Условия и циклы прописываются так же как и в Python.


## Delta

В методе `_process` виден аргумент delta. Это аналог deltaTime в Unity. Нужен он для того, чтобы игра имела одинаковую скорость на разных устройствах.


## Inputы

Пойдет речь об управлении с клавиатуры и мыши.

Для начала нужно создать входную карту. Для этого в топбаре нужно нажать Проект/Настройки проекта и перейти в вкладку Список действий. Придумайте имя и нажмите Добавить. Если нажать на Плюс, то можно перейти в окно добавления клавиш. Можно выбрать из списка или нажать клавишу в прослушивающем поле. Затем нажать Ок. Например для действия right можно назначить клавишу D и Правую стрелку.

Теперь можно перейти в редактор кода, создав скрипт на объекте. Выполнять проверки на нажатие нужно в `_process`. Проверка начинается с ключевого слова Input, который имеет несколько свойств. `Input.is_action_just_pressed` - действие при простом нажатии. `is_action_just_released` - действие при простом отпускании кнопки. `is_action_pressed` - действие при зажатии кнопки.

Пример:
Создадим 4 действия и добавим им 4 кнопки соответственно. Действия назовем как и кнопки. Дальше можно проверять в условии - данный код осуществляет простое управление.

```
if Input.is_action_pressed('d'):
	position.x+=200*delta
if Input.is_action_pressed('a'):
	position.x-=200*delta
if Input.is_action_pressed('w'):
	position.y-=200*delta
if Input.is_action_pressed('s'):
	position.y+=200*delta
```


## Физика

Далее будут представлены физические компоненты


| Название        | Описание                                                             |
| --------------- | -------------------------------------------------------------------- |
| Area2D          | Зона, в которую входит игрок или что-то другое. Триггер.             |
| StaticBody2D    | Различные статические объекты. Стены, заборы и так далее. Коллайдеры |
| RigidBody2D     | Твердое тело                                                         |
| CharacterBody2D | Персонажи                                                            |

Для добавления физики на ноду щелкните ПКМ по ней и выберите Изменить тип. Далее выберите нужное физическое свойство. Желательно помещать ноду, на которую нужно назначить физику, в новую сцену и назначать физику именно на ноду сцены.

### Добавление StaticBody2D

Для добавления коллайдера измените тип того объекта (сцены), на котором он должен быть. Установите тип на StaticBody2D. После этого в ноде появится предупреждение, в котором сказано, что коллайдеру нужна форма. Для этого нужно ее добавить в виде дочернего объекта, выделив ноду и нажав на Плюс. Добавьте CollisionShape2D. Выделите добавленную ноду и в Инспекторе, в Shape, выберите прямоугольник. Его можно двигать и трансформировать с помощью точек. Если нажать на точку трансформации с Alt, то трансформация будет происходить в обе стороны.


### Добавление CharacterBody2D

Здесь нужно поступить точно так же - добавить персонажа в новую сцену, если ранее это не было сделано, изменить тип этой сцены на CharacterBody2D и привязать сцену к основной. Назначьте скрипт сцене персонажа - можно просто выделить сцену и перетащить в нее скрипт из Браузера. Для перемещения игрока скрипт нужно немного видоизменить.

В примере ниже не будет условий. Вместо этого мы получим вектор, в котором есть значения -1, 1, -1, 1. Соответственно влево, вправо, вверх и вних. Пока клавиша не нажата, переменная будет равна 0, но когда будет нажатие соответствующей клавиши, то значение станет 1.

```
extends CharacterBody2D # Здесь меняем тип как и в типе ноды
func _process(delta):
	var direction=Input.get_vector("a","d","w","s") # Получение вектора
	velocity=direction*500 # Добавление скорости к физическому параметру velocity
	move_and_slide() # Специальный метод отвечающий за физическое перемещение
```

Еще один способ использовать CharacterBody выглядит следующим образом.

```
velocity=Vector2(x*speed*delta,y*speed*delta)
move_and_slide()
```

В этом примере реализовано движение по прямой.

Часто бывает ситуация, когда нужно персонажа не просто перемещать, но и поворачивать. Но, если персонажа просто повернуть, направление движения останется прежним. Код ниже позволяет исправить это.

```
var speed=100
...
velocity=Vector2.ZERO # Сброс значений до 0, чтобы при отпускании клавиши персонаж останавливался
if Input.is_action_pressed('W'):
	velocity=Vector2(cos(rotation)*speed*delta,sin(rotation)*speed*delta)
elif Input.is_action_pressed('S'):
	velocity=Vector2(-cos(rotation)*speed*delta,-sin(rotation)*speed*delta)
if Input.is_action_pressed('A'):
	rotation-=2*delta
elif Input.is_action_pressed('D'):
	rotation+=2*delta
move_and_slide()
```

Обратите внимание, что вместо чисел мы передаем синусы и косинусы поворота. В таком случае все будет работать. Так же обратите внимание на velocity - это свойство CharacterBody, которое влияет на придание ускорения.

### Добавление Area2D

Area2D используется в качестве триггера. То есть что-то происходит, когда что-то входит или выходит из Area.

Создайте новую сцену и измените тип корневой ноды на Area2D. Добавьте в сцену спрайты или другие объекты как дочерние. Далее выберите корневую ноду сцены и добавьте в качестве дочерней ноды CollisionShape2D и измените форму как нужно. Сохраните сцену и привяжите ее к основной сцене. В основной сцене выделите ноду ранее созданной сцены и в инспекторе перейдите в вкладку Узел, в вкладку Сигналы и выберите нужный сигнал. Далее откроется окно, где можно выбрать, куда примонтировать метод сигнала - нужно выбрать ноду, в которой есть скрипт и где это уместно. В коде появится новый метод. В примере ниже будет выводиться сообщение всякий раз, когда игрок попадает в Area.

```
func _on_block_body_entered(body):
	print("Hello")
```


## Добавление объектов

Далее приведенным способом можно добавлять объекты и сцены, которые были сохранены. Нижеприведенный код будет добавлять сцену в корневую сцену при старте игры. В первой строке объявляется переменная которая хранит предзагруженную сцену. Далее, в методе `_ready`, сначала объявляется переменная, которая спавнит сцену, а строка ниже помещает сцену как дочерний объект.

```
var carScene: PackedScene=preload("res://Scenes/Objects/car.tscn")
func _ready():
	var car=carScene.instantiate()
	add_child(car)
```


## Получение дочерних объектов

Создайте скрипт и поместите его в сцене, где находится обхект с дочерними элементами. Нижеприведенный код выведет дочерние элементы в виде списка, а дальше с ним можно делать то, что вам заблагорассудится.

```
print($нода.get_children())
```


## Анимация

### Анимация секвенции

Данный способ подходит для анимирования серии изображений. Добавьте ноду AnimateSprite2D. В инспекторе разверните подменю Animation и в SpriteFrames добавьте новый и нажмите по созданному - откроется окно управления фреймовой анимацией. В Браузере выберите первую картинку и с зажатым Shift выберите последнюю - выделятся все картинки и перетащите их в поле справа в новом окне работы с анимацией. Далее полученную анимацию можно воспроизвести, изменить ее скорость и так далее, используя кнопки в топбаре окна анимаций.

Если сейчас запустить игру, анимация проигрываться не будет. Чтоб это исправить, нужно нажать в окне анимации кнопку Автовоспроизведение.


### Покадровая анимация

С помощью покадровой анимации можно анимировать почти любое свойство, будь то трансформация, мощность освещения, цвет и так далее.

Добавьте в сцену ноду AnimationPlayer. Щелкнув по нему, отобразится окно покадровой анимации. Для начала нажмите на кнопку Анимация/New, чтобы добавить новую дорожку анимации. Появится временная шкала. Далее нажмите на Добавить дорожку/Property Track, чтобы добавить свойство. Откроется окно с выбором ноды. Выбрав нужную, будет выбор свойства. К примеру Scale. Передвиньте ползунок времени и нажмите ПКМ по временой шкале свойства и выберите Insert Key, чтобы добавить ключ. Перейдите в другое место временной шкалы и проделайте то же самое и так далее. Щелкнув по нужному ключу на таймлайне, в Инспекторе появится окно с свойством, куда можно вписать свое значение. 

### Анимация прозрачности

Напрямую нельзя анимировать альфа канал, но есть обходной путь - анимировать через ноду Panel. Для примера разберем вот такое древо нодов. Задача - сделать затемнение экрана.

```
EndGame
  Control
    Panel
```

В Panel создайте тему оформления в вкладке ThemeOwerride и настройте ее внешний вид без учета прозрачности. Далее добавьте ноду AnimationPlayer и в свойствах выберите ноду Control/Modulate. Создайте ключевые кадры и уже в них можно менять прозрачность.



## Уничтожение объекта

```
объект.queue_free()
```


## Переход в другую сцену

```
get_tree().change_scene_to_file("файлСцены")
```


## Создание переменных цвета

```
# Используя код цвета
var col=Color('кодЦвета')

# Используя RGB
var col=Color(числоR, числоG, числоB, alpha)
```


## Сигналы

Сигналы позволяют связывать несколько нод, даже из разных сцен. 

Пример:
Создать кнопку, при нажатии на которую в консоли выводится текст.
1. Создать сцену и добавить в нее кнопку.
2. На кнопку добавить скрипт. В инспекторе перейти в Ноды - Сигналы. Здесь можно увидеть много сигналов, которые применимы к кнопке. Сигналы можно рассматривать и как методы, которые вызываются при определенных условиях. Найдите сигнал pressed - он отвечает за то, что будет происходить при нажатии на кнопку. 2 раза ЛКМ по сигналу и откроется окно, где можно привязать сигнал. Привязывать его надо туда, где есть скрипт - там будет создан метод. В нем уже нужно писать код, который будет выполняться при нажатии на кнопку. В нашем случае будет печататься текст.
```
func _on_button_pressed() -> void:
	print("Текст)
```

Таким образом можно даже связывать ноды из разных сцен. Главное, чтобы на корневых нодах были скрипты.


### Кастомные сигналы

Есть возможность создавать и свои сигналы. Например, чтобы связывать сцены или лаконично использовать код.

Пример
1. Создайте сцену, назовите ее Tumbler.
2. Создайте вторую сцену, назовите ее Sprites и добавьте в нее 2 иконки Godot, расположите их как захотите. Таким образом дерево сцены будет выглядеть примерно так...
```
Node2D
	Icon
	Icon2
```
3. Перейдите в Tumbler и добавьте в него сцену Sprites. Добавьте в корень Tumbler скрипт. В скрипте мы объявляем переменную tumblerItems и создаем сигнал, просто написав ключевое слово signal и дав ему название. Как вы помните, сигнал срабатывает, если выполняется определенное условие. В данном примере сигнал сработает, если tumblerItems будет больше 5.
```
extends Node2D
var tumblerItems=0
signal isTumbler
func _process(delta: float) -> void:
	if tumblerItems>5:
		emit_signal("isTumbler")
```
4. Теперь нужно подключить сигнал. Перейдите в сцену Sprites и в корне создайте скрипт. Далее перейдите в Tumbler и выберите в инспекторе ноду, на которую прикрепили скрипт с сигналом. Перейдите в Инспектов/Узел/Сигналы - выберите ранее созданный сигнал и прикрепите к корневой ноде второй сцены. Если скрипт в главной сцене не появился, сохраните сцену Sprites. Перейдите в скрипт, на который был назначен сигнал - там появился метод, который похож на имя сигнала. В нем напишите нужный код.
```
func _on_node_2d_is_tumbler() -> void:
	$Icon2.visible=false
```
5. Поизменяйте значение tumblerItems, периодически запуская игру. Если значение будет больше 5, спрайт исчезнет.


### Подключение сигналов в коде

Это может быть необходимо, если сцены загружаются динамически, например, если в процессе игры спавнятся враги.

Пример:
Для примера воспользуйтесь предыдущим проектом, но немного его измените. Удалите дочернюю ноду в сцене Tumbler. Далее измените скрипт корневой ноды. Здесь объявляется переменная `_spriteScene`, которая загружает сцену Sprites. Так же добавляется метод `_ready`и в него инстанцируется переменная сцены, объявляя под новой переменной. Затем идет добавление ее в сцену как дочерний объект. Далее происходит connect сигнала. Первым параметром передается имя сигнала, затем идет Collable, куда передается переменная сцены и название метода.
```
extends Node2D
var tumblerItems=0
var _spriteScene=load("res://Sprites.tscn")
signal isTumbler
func _ready() -> void:
	var spriteScene=_spriteScene.instantiate()
	add_child(spriteScene)
	connect("isTumbler",Callable(spriteScene,"_on_node_2d_is_tumbler"))
func _process(delta: float) -> void:
	if tumblerItems>5:
		emit_signal("isTumbler")
```

Узнать метод сигнала можно, просто нажав 2 раза по сигналу в инспекторе и скопировав оттуда название метода.
Если сигнал был создан не в корне основной ноды, а в динамически подгружаемом скрипте, то перед connect нужно указать переменную сцены, где был создан сигнал.

```
сценаССигналом.connect(содержимое)
```


## Пауза

Поставить игру на паузу можно используя следующий код:

```
get_tree().paused=true # Поставить на паузу
get_tree().paused=false # Снять с паузы
```

Если просто поставить игру на паузу, это поставит всю игру на паузу. Это значит, что ничего сделать в игре вы не сможете. Существует несколько режимов процессов, которые нужно учитывать при постановке игры на паузу. Выбрать нужный режим можно в инспекторе, в вкладке Process, которая есть у нодов. Можно выставить режим на Always - тогда пауза будет затрагивать все узлы кроме того, в котором выставлен Always.


## Рандомизация

Для рандомизации лучше воспользоваться randi_range(), куда первым параметром передать начальное число, а вторым - конечное. Например, если задать -10 и 10, то на выходе будет случайное число от -10 до 10. Чтобы получить дробное число, воспользуйтесь так же randf_range().

```
print(randi_range(-5,5))
```


## Работа с стилями

В Godot есть встроенный инструмент для стилизации UI. Есть возможность настраивать стили как в Инспекторе, так и с помощью кода.

### Настройка стилей в инспекторе

Далее будут рассматриваться настройки на примере кнопки. Настройки стилей находятся в вкладке Theme Overrides. В Colors содержатся настройки цвета для текста и иконки. В Constants содержатся константы отвечающие за размер обводки, иконки и так далее. В Fonts можно настроить шрифты. В Font Sizes настраивается размер шрифтов. В Icons можно настроить иконку. В Styles можно настроить стиль.

Именно Styles отвечает за стиль кнопки, а не ее составляющих. Если перейти в данную вкладку, можно увидеть много состояний, в данном случае кнопки. для каждого состояния можно настроить стиль. StyleBoxFlat - стиль без текстуры, а если нужно использовать текстуру, то нужно выбрать StyleBoxTexture. После создания стиля, на него можно кликнуть и откроется меню настройки стиля, где можно настроить цвет или текстуру.

### Настройка стилей в скрипте

Для примера создайте сцену с корнем Control и добавьте дочернюю кнопку - Button. В корне создайте скрипт. Ниже будет представлен простой пример того, как менять стиль при помощи скрипта. Обратите внимание - переменная объявляется в методе ready - то есть стиль создается при запуске. В первой строке объявляется переменная стиля и берется уже имеющийся стиль. Далее идет duplicate. Это нужно, чтобы сделать стиль для кнопки уникальным. Если его не использовать, то изменения будут применены ко всем кнопкам. Далее, в второй строке задается свойство - в данном примере - цвет фона. В третьей строке созданный стиль применяется к кнопке.

```
func _ready() -> void:
	var stylebox = $Button.get_theme_stylebox("normal").duplicate()
	stylebox.bg_color=Color(1.0, 0.0, 0.0)
	$Button.add_theme_stylebox_override("normal",stylebox)
```

### Свойства StyleBoxFlat

| Свойство                       | Описание                                                                           | Тип данных                 |
| ------------------------------ | ---------------------------------------------------------------------------------- | -------------------------- |
| **anti_aliasing**              | Сглаживание                                                                        | bool                       |
| **anti_aliasing_size**         | Уровень сглаживания                                                                | int, float                 |
| **bg_color**                   | Цвет фона                                                                          | Color(float, float, float) |
| **border_blend**               | Смешивание обводки с цветом фона                                                   | bool                       |
| **border_color**               | Цвет обводки                                                                       | Color(float, float, float) |
| **border_width_bottom**        | Ширина обводки снизу                                                               | int                        |
| **border_width_left**          | Ширина обводки слева                                                               | int                        |
| **border_width_right**         | Ширина обводки справа                                                              | int                        |
| **border_width_top**           | Ширина обводки сверху                                                              | int                        |
| **corner_detail**              | Подразделение скругления углов. Это нужно при включении параметра скругления углов | int                        |
| **corner_radius_bottom_left**  | Радиус скругления угла снизу слева                                                 | int                        |
| **corner_radius_bottom_right** | Радиус скругления угла снизу справа                                                | int                        |
| **corner_radius_top_left**     | Радиус скругления угла сверху слева                                                | int                        |
| **corner_radius_top_right**    | Радиус скругления угла сверху справа                                               | int                        |
| **draw_center**                | Отрисовка внутренней части                                                         | bool                       |
| **expand_margin_bottom**       | Расширяет кнопку вниз, но не ее кликабельную часть                                 | int                        |
| **expand_margin_left**         | Расширяет кнопку влево, но не ее кликабельную часть                                | int                        |
| **expand_margin_right**        | Расширяет кнопку вправо, но не ее кликабельную часть                               | int                        |
| **expand_margin_top**          | Расширяет кнопку вверх, но не ее кликабельную часть                                | int                        |
| **shadow_color**               | Цвет тени                                                                          | Color(float, float, float) |
| **shadow_offset**              | Смещение тени                                                                      | Vector2(float,float)       |
| **shadow_size**                | Размер тени                                                                        | int                        |
| **skew**                       | Деформация                                                                         | Vector2(float,float)       |


### Свойства StyleBoxTexture

Для загрузки текстуры можно воспользоваться load. Так же, в Инспекторе, нужно явно добавить StyleBlockTexture.

```
stylebox.texture=load("текстура")
```

| Свойство                | Описание                                                                                                                                      | Тип данных                        |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------- |
| axis_stretch_horizontal | Включает режим плитки по горизонтали. Если 0 - значение по умолчанию. 1 - режим плитки - при растягивании элемента текстура будет повторяться |                                   |
| axis_stretch_vertical   | Включает режим плитки по вертикали. Если 0 - значение по умолчанию. 1 - режим плитки - при растягивании элемента текстура будет повторяться   |                                   |
| draw_center             | Отрисовка внутренней части                                                                                                                    | bool                              |
| expand_margin_bottom    | Расширяет кнопку вниз, но не ее кликабельную часть                                                                                            | int                               |
| expand_margin_left      | Расширяет кнопку влево, но не ее кликабельную часть                                                                                           | int                               |
| expand_margin_right     | Расширяет кнопку вправо, но не ее кликабельную часть                                                                                          | int                               |
| expand_margin_top       | Расширяет кнопку вверх, но не ее кликабельную часть                                                                                           | int                               |
| modulate_color          | Подмешивание дополнительного цвета                                                                                                            | Color(float, float, float, float) |
| region_rect             | Отображает указанный регион текстуры                                                                                                          | Rect2(int, int, int, int)         |
| texture                 | Текстура кнопки                                                                                                                               | load()                            |
| texture_margin_bottom   | Нижний внутренний отступ                                                                                                                      | int                               |
| texture_margin_left     | Левый внутренний отступ                                                                                                                       | int                               |
| texture_margin_right    | Правый внутренний отступ                                                                                                                      | int                               |
| texture_margin_top      | Верхний внутренний отступ                                                                                                                     | int                               |











