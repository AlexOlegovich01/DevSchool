# Базовый скриптинг

## Методы скриптов

- Start - запускается в момент создания объекта в игре.
- Update - выполняется каждый кадр.

## 2D проект

В 2D проекте игровые элементы - это спрайты, но на них так же может действовать физика, но в двумерном пространстве. По горизонтали идет ось X, по вертикали - Y.

1. Добавим 2 спрайта - Floor и Player. Разместим игрока над полом.
2. Добавим на них компоненты коллайдер 2д. Это нужно, чтобы объекты не проходили сквозь друг друга.
3. Для Player добавим RigidBody и запустим игру.

### Установка начального положения игрока

1. Создать скрипт, в нем написать этот код

```csharp
void Start()
    {
        transform.position = new Vector2(0, 10);
    }
```

2. Повесить скрипт на Player.

### Движение игрока по прямой

1. Создать скрипт. В нем написать код.

```csharp
void Update()
    {
        transform.Translate(new Vector2(1*Time.deltaTime,0));
    }
```

2. Повесить скрипт на Player.

### Взаимодействие с другими объектами

1. Добавим новый объект и назовем его Bonus - это будет что-то типа жизней или монет - да все, что угодно.
2. Создадим новый скрипт и повесим его на Bonus.

```csharp
public GameObject PlayerForDestroy;
void Update()
{
    if (PlayerForDestroy.transform.position.x>= transform.position.x)
    {
        Debug.Log("Бонус взят!");
    }
}
```

Обратите внимание на то, как мы объявили переменную. public указывает на то, что переменную можно менять в инспекторе.
3. В инспекторе бонуса видим скрипт, а в нем есть поле, которое называется так, как и переменная. Теперь перетащем префаб игрока в это поле. 

При запуске игры видим появившееся сообщение при достижении игрока центра богуса.

### OnTrigger и OnCollision

Обработка событий столкновений и взаимодействий.

#### OnCollisionEnter2D

Создадим скрипт и повесим его на игрока. При запуске игры увидим сообщение при столкновении игрока с другими телами.

```csharp
void OnCollisionEnter2D(Collision2D col)
{
    Debug.Log("Finish");
}
```

#### OnTriggerEnter2D

Нижеприведенный скрипт нужно закинуть на объект, который будет триггером, например бонус. В объекте должен быть коллайдер, а в нем поставлена галочка Is Trigger.

```csharp
void OnTriggerEnter2D(Collider2D other)
{
    Debug.Log("Finish");
}
```

### Коррутины

Коррутина - скрипт, который обеспечивает задержку во времени.

```csharp
float sp = 0.2f;
void Start()
{
    transform.position = new Vector2(-10, 10);
}

void Update()
{
    transform.Translate(new Vector2(sp*Time.deltaTime,0));
    if (transform.position.x>-6)
    {
        StartCoroutine(Speed()); /*Запуск коррутины*/
    }
}
IEnumerator Speed() /*Коррутина*/
{
    sp = 2; /*Во время срабатывания*/
    yield return new WaitForSeconds(1); /*Продолжительность работы*/
    sp = 0.2f; /*По истечении времени*/
}
```

### Raycast

Речь пойдет о луче, который используется как прицел в играх и для других похожих вещей.

#### Имитация прицеливания

1. Создадим 3д проект, в нем создадим объект, который будет типа нашей целью.
2. Создать скрипт и повесить на камеру.

```csharp
public float rayDistance; /*Длина луча*/
void Update()
{
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); /*Получаем лучь объекта из позиции мыши*/
    Debug.DrawRay(transform.position, ray.direction * rayDistance); /*Выполняет рисование луча*/
    //transform.position - положение камеры
    //ray.direction - направление луча
    if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
    {
        if (Physics.Raycast(ray)) /*Если луч попадает в цель*/
        {
            Debug.Log("Вы попали в цель!");
        }
    }
}
```

3. При запуске игры, если щелкнуть ЛКМ по цели, в консоли появится сообщение. Если не выключать режим игры и перейти в вкладку сцены, то луч мы не видим. Чтобы его увидеть, нужно установить значение для публичной переменной rayDistance.
4. Есть проблема. Наш код реагирует на то, куда указывает луч, но, если длина луча не достигает цели, все равно выводится сообщение в консоль. Давайте сделаем так, чтобы сообщение выводилось только в том случае, когда длина луча достаточна, чтобы достигнуть цели.

```csharp
if (Physics.Raycast(ray,rayDistance))
```

5. Теперь поговорим об определении, в какой именно объект мы стреляем. Этого можно достигнуть при использовании переменной типа RaycastHit.

```csharp
RaycastHit hit;
if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
{
    if (Physics.Raycast(ray,out hit)) /*Если луч попадает в цель*/
    {
        Debug.Log("Вы попали в цель!"+hit.transform.position);
    }
}
```

В данном случае выведутся координаты того объекта, куда стреляли, но можно вывести и другие результаты, например имя.

```csharp
Debug.Log("Вы попали в цель!"+hit.collider.gameObject.name);
```

Или даже менять параметры

```csharp
if (Physics.Raycast(ray,out hit)) /*Если луч попадает в цель*/
{
    hit.collider.gameObject.name = "R.I.P";
}
```

6. Так же можно получать данные нескольких объектов, собрав их в массиве, если луч пересекает несколько объектов.

```csharp
RaycastHit[] hits;
if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
{
    hits = Physics.RaycastAll(ray);
    foreach (RaycastHit hit in hits)
    {
        Debug.Log(hit.transform.position);
    }
}
```