# Базовый скриптинг

## Методы скриптов

- Start - запускается в момент создания объекта в игре.
- Update - выполняется каждый кадр.

## 2D проект

В 2D проекте игровые элементы - это спрайты, но на них так же может действовать физика, но в двумерном пространстве. По горизонтали идет ось X, по вертикали - Y.

1. Добавим 2 спрайта - Floor и Player. Разместим игрока над полом.
2. Добавим на них компоненты коллайдер 2д. Это нужно, чтобы объекты не проходили сквозь друг друга.
3. Для Player добавим RigidBody и запустим игру.

### Установка начального положения игрока

1. Создать скрипт, в нем написать этот код

```csharp
void Start()
    {
        transform.position = new Vector2(0, 10);
    }
```

2. Повесить скрипт на Player.

### Движение игрока по прямой

1. Создать скрипт. В нем написать код.

```csharp
void Update()
    {
        transform.Translate(new Vector2(1*Time.deltaTime,0));
    }
```

2. Повесить скрипт на Player.

### Взаимодействие с другими объектами

1. Добавим новый объект и назовем его Bonus - это будет что-то типа жизней или монет - да все, что угодно.
2. Создадим новый скрипт и повесим его на Bonus.

```csharp
public GameObject PlayerForDestroy;
void Update()
{
    if (PlayerForDestroy.transform.position.x>= transform.position.x)
    {
        Debug.Log("Бонус взят!");
    }
}
```

Обратите внимание на то, как мы объявили переменную. public указывает на то, что переменную можно менять в инспекторе.
3. В инспекторе бонуса видим скрипт, а в нем есть поле, которое называется так, как и переменная. Теперь перетащем префаб игрока в это поле. 

При запуске игры видим появившееся сообщение при достижении игрока центра богуса.

### OnTrigger и OnCollision

Обработка событий столкновений и взаимодействий.

#### OnCollisionEnter2D

Создадим скрипт и повесим его на игрока. При запуске игры увидим сообщение при столкновении игрока с другими телами.

```csharp
void OnCollisionEnter2D(Collision2D col)
{
    Debug.Log("Finish");
}
```

#### OnTriggerEnter2D

Нижеприведенный скрипт нужно закинуть на объект, который будет триггером, например бонус. В объекте должен быть коллайдер, а в нем поставлена галочка Is Trigger.

```csharp
void OnTriggerEnter2D(Collider2D other)
{
    Debug.Log("Finish");
}
```

### Коррутины

Коррутина - скрипт, который обеспечивает задержку во времени.

```csharp
float sp = 0.2f;
void Start()
{
    transform.position = new Vector2(-10, 10);
}

void Update()
{
    transform.Translate(new Vector2(sp*Time.deltaTime,0));
    if (transform.position.x>-6)
    {
        StartCoroutine(Speed()); /*Запуск коррутины*/
    }
}
IEnumerator Speed() /*Коррутина*/
{
    sp = 2; /*Во время срабатывания*/
    yield return new WaitForSeconds(1); /*Продолжительность работы*/
    sp = 0.2f; /*По истечении времени*/
}
```

### Raycast

Речь пойдет о луче, который используется как прицел в играх и для других похожих вещей.

#### Имитация прицеливания

1. Создадим 3д проект, в нем создадим объект, который будет типа нашей целью.
2. Создать скрипт и повесить на камеру.

```csharp
public float rayDistance; /*Длина луча*/
void Update()
{
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); /*Получаем лучь объекта из позиции мыши*/
    Debug.DrawRay(transform.position, ray.direction * rayDistance); /*Выполняет рисование луча*/
    //transform.position - положение камеры
    //ray.direction - направление луча
    if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
    {
        if (Physics.Raycast(ray)) /*Если луч попадает в цель*/
        {
            Debug.Log("Вы попали в цель!");
        }
    }
}
```

3. При запуске игры, если щелкнуть ЛКМ по цели, в консоли появится сообщение. Если не выключать режим игры и перейти в вкладку сцены, то луч мы не видим. Чтобы его увидеть, нужно установить значение для публичной переменной rayDistance.
4. Есть проблема. Наш код реагирует на то, куда указывает луч, но, если длина луча не достигает цели, все равно выводится сообщение в консоль. Давайте сделаем так, чтобы сообщение выводилось только в том случае, когда длина луча достаточна, чтобы достигнуть цели.

```csharp
if (Physics.Raycast(ray,rayDistance))
```

5. Теперь поговорим об определении, в какой именно объект мы стреляем. Этого можно достигнуть при использовании переменной типа RaycastHit.

```csharp
RaycastHit hit;
if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
{
    if (Physics.Raycast(ray,out hit)) /*Если луч попадает в цель*/
    {
        Debug.Log("Вы попали в цель!"+hit.transform.position);
    }
}
```

В данном случае выведутся координаты того объекта, куда стреляли, но можно вывести и другие результаты, например имя.

```csharp
Debug.Log("Вы попали в цель!"+hit.collider.gameObject.name);
```

Или даже менять параметры

```csharp
if (Physics.Raycast(ray,out hit)) /*Если луч попадает в цель*/
{
    hit.collider.gameObject.name = "R.I.P";
}
```

6. Так же можно получать данные нескольких объектов, собрав их в массиве, если луч пересекает несколько объектов.

```csharp
RaycastHit[] hits;
if (Input.GetMouseButtonDown(0)) /*Если нажата ЛКМ*/
{
    hits = Physics.RaycastAll(ray);
    foreach (RaycastHit hit in hits)
    {
        Debug.Log(hit.transform.position);
    }
}
```

### Управление персонажем

Создадим простой скрипт, с помощью которого можно перемещать персонажа влево и вправо.

```csharp
float speed = 1; /*Переменная для скорости*/
float speedMode; /*Направление персонажа*/

void FixedUpdate()
{
    if (Input.GetKey(KeyCode.D)) /*Если нажата D*/
    {
        speedMode = speed; /*Направление вправо*/
    }
    else if (Input.GetKey(KeyCode.A)) /*Если нажата A*/
    {
        speedMode = -speed; /*Направление влево*/
    }
    transform.Translate(new Vector2(speedMode, 0)*Time.deltaTime); /*Как раз перемещение персонажа*/
    speedMode = 0; Сброс скорости на 0, когда ничего не нажато

}
```

Теперь нужно сделать так, чтобы игрок смотрел в том направлении, в котором идет движение. Под объявленными переменными скорости, объявим еще 2, которые отвечают за Scale.

```csharp
float beginScale; /*Начальный размер игрока*/
float scale; /*Размер игрока*/
```

Суть в том, что,когда меняем размер на то же значение, но со знаком минус, объект инвертируется, то есть в нашем случае смотрит в другую сторону. Теперь надо в методе Start получить оригинальный размер игрока и записать его в переменную.

```csharp
void Start()
    {
        beginScale = transform.lossyScale.x;
    }
```

Теперь FixedUpdate немного преобразовался.

```csharp
void FixedUpdate()
{
    if (Input.GetKey(KeyCode.D))
    {
        speedMode = speed;
        scale = beginScale; /*Обычный размер*/
    }
    else if (Input.GetKey(KeyCode.A))
    {
        speedMode = -speed;
        scale = -beginScale; /*Инверсированный размер*/
    }
    transform.localScale = new Vector2(scale, transform.lossyScale.y); /*Как раз изменение размера*/
    transform.Translate(new Vector2(speedMode, 0)*Time.deltaTime);
    scale = beginScale; /*В любом случае переходит в начальный размер*/
    speedMode = 0;
}
```

### Прыжки

Для удобства создадим новый скрипт. Объявим вне методов 3 переменные.

```csharp
float jump; /*Величина прыжка*/
Rigidbody rb; /*Переменная компонента RigidBody*/
bool mode; /*Переключатель*/
```

Получим компонент Rigidbody.

```csharp
void Start()
{
    rb = GetComponent<Rigidbody2D>();
}
```

Можно было бы просто вызвать условие нажатия клавиши для прыжка в методе FixedUpdate, но возникнет проблема - игрок будет прыгать не всегда. Объясняется это тем, что метод Update вызывается каждый кадр, а метод FixedUpdate - нет. Поэтому будем вызывать проверку в Update и вызывать прыжок в FixedUpdate. Вот тут и пригодится переменная переключатель.

```csharp
void Update()
{
    if (Input.GetKeyDown(KeyCode.W))
    {
        mode=true;
    }
}
```

Далее следует сбросить переключатель и выполнить прыжок в FixedUpdate, если нажата кнопка прыжка.

```csharp
void FixedUpdate()
{
    if (mode)
    {
        mode=false;
        rb.AddForce(new Vector2(0, jump), ForceMode2D.Impulse);
    }
}
```



Теперь камеру запихнуть в игрока, чтоб она была дочерним элементом. Но и сейчас есть проблема - при прыжке изображение может заваливаться. Чтобы такого не было, в RigidBody игрока нужно поставить констреинт на ось Z.

Игрок может подпрыгивать, когда находится в воздухе. Это нужно тоже исправить. Для начала надо создать еще одну булеву переменную вне методов. Она будет активна, когда игрок находится на поверхности.

```csharp
bool isGrounded;
```

Дополнить строку условия нажатия клавиши прыжка.

```csharp
if (Input.GetKeyDown(KeyCode.W) && isGrounded)
```

Далее нужно добавить 2 метода. OnCollisionEnter2D обрабатывает соьытия физического взаимодействия с объектом, а метод OnCollisionExit2D обрабатывает, что будет, когда объекты перестают взаимодействовать.

```csharp
void OnCollisionEnter2D(Collision2D col)
{
    if(col.gameObject.tag=="Ground")
    {
        isGrounded=true;
    }
}
void OnCollisionExit2D(Collision2D col)
{
    if(col.gameObject.tag=="Ground")
    {
        isGrounded=false;
    }
}
```

Обязаельно проставить всем поверхностям тег. В нашем случае - это тег Ground.

Небольшое пояснение по коду. Активная переменная isGrounded означает, что игрок стоит на поверхности. В условии сказано, что если кнопка прыжка нажата и игрок стоит на поверхности, значит выполняется физика прыжка. А когда игрок находится в воздухе, переменная isGrounded переходит в отрицание, которое не соответствует условию.

### Создание кнопок

Это умение будет полезно для создания игр в том числе и для телефонов.